package gen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"regexp"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

type Err struct {
	code        int
	errName     string
	httpErrName string
	errMsg      string
}

var (
	titleRegexp = regexp.MustCompile(`[A-Z]`)
)

func Generate(swagger *openapi3.Swagger, pkgName, folderName string) error {
	buf := bytes.Buffer{}
	buf.WriteString(`// Code generated by error_code_gen DO NOT EDIT.
package ` + pkgName + `

import (
	"net/http"
)

var (
`)

	for k, v := range swagger.Components.Schemas {
		if k == "ErrorCode" {
			if v.Value != nil {
				val := *v.Value
				var names []string
				if v, ok := val.ExtensionProps.Extensions["x-enum-varnames"]; ok {
					if j, ok := v.(json.RawMessage); ok {
						b, err := j.MarshalJSON()
						if err != nil {
							return err
						}
						err = json.Unmarshal(b, &names)
						if err != nil {
							return err
						}
					}
				}

				maxLen := 0
				errs := make([]*Err, len(val.Enum))
				for i := 0; i < len(val.Enum); i++ {
					xnames := strings.SplitN(names[i], ",", 3)
					code, ok := val.Enum[i].(float64)
					if !ok {
						return fmt.Errorf("%v is not number", val.Enum[i])
					}
					if len(xnames) == 0 {
						return fmt.Errorf("xnames len is 0")
					}

					errName0 := strings.TrimSpace(xnames[0])

					var errName, httpErrName, errMsg string
					switch len(xnames) {
					default:
						return fmt.Errorf("xnames len is not < 3: %d", len(xnames))
					case 1:
						errName = "Err" + errName0
						if len(errName) > maxLen {
							maxLen = len(errName)
						}
						httpErrName = "http.Status" + errName0
						errMsg = toSentence(errName0)
					case 2:
						errName = "Err" + strings.TrimSpace(xnames[1])
						httpErrName = "http.Status" + errName0
						errMsg = toSentence(xnames[1])
					case 3:
						errName = "Err" + strings.TrimSpace(xnames[1])
						httpErrName = "http.Status" + errName0
						errMsg = strings.TrimSpace(xnames[2])
					}
					errs[i] = &Err{
						code:        int(code),
						errName:     errName,
						httpErrName: httpErrName,
						errMsg:      errMsg,
					}
				}
				for _, x := range errs {
					buf.WriteByte('\t')
					buf.WriteString(fmt.Sprintf("%-*s", maxLen, x.errName))
					buf.WriteString(" = New(")
					buf.WriteString(x.httpErrName)
					buf.WriteString(", ")
					buf.WriteString(fmt.Sprintf(`%d, "`, x.code))
					buf.WriteString(x.errMsg)
					buf.WriteString("\")\n")
				}

			}
		}
	}
	buf.WriteString(")\n")
	fname := path.Join(folderName, "code.gen.go")
	f, err := os.OpenFile(fname, os.O_CREATE|os.O_RDWR, 0644)
	if err != nil {
		return err
	}
	_, err = f.Write(buf.Bytes())
	if err != nil {
		return err
	}
	fmt.Printf("%s generated\n", fname)

	return nil
}

func toSentence(s string) string {
	return string(bytes.TrimSpace(titleRegexp.ReplaceAllFunc(bytes.TrimSpace([]byte(s)), func(b []byte) []byte {
		return append([]byte(" "), bytes.ToLower(b)...)
	})))
}

